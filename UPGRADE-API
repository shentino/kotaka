Current API changes pending
---------------------------

ModuleD will be official registry for modules

	In the future, the existence of a module's InitD will no longer
	be the official indication of the module's being online.

	Step 1

		Usage of the module's initd's existence as an indication
		of the module's status will be formally deprecated.

		Going forward, ModuleD should be explicitly queried
		regarding a module's state.

		ModuleD's interface for booting and shutting down modules
		should be used exclusively.

		A module can be nuked even if it's shut down to enforce a
		complete purge of its owned objects.

	Step 2

		ModuleD's record on the status of a particular module
		will no longer automatically reflect the status of the
		module's initd.

		Modules will only be sent signals by ModuleD if they are
		officially online according to ModuleD's records

		A module registered as online, but whose initd is not
		compiled, will be an anomalous state that will generate a
		runtime error.  Such a detected status will cause the
		defunct module's missing initd to be deprived of signals.

Amendment of constructors and destructors

	Constructors and destructors are still useful, they are therefore
	being reinstated.

	However, due to the ability of a program to arbitrarily add and
	remove inheritables on recompilation, a caveat is announced.

	Inheritables are warned that their constructor might not be
	properly called if an object inherits them after a clone has been
	created.  It is advisable to have a patcher registered to check
	for this.

	Inheritables are also warned that they may be removed at any time
	from an object before the object is destructed, and thus, that
	the destructor might not be called.

	If an inheritable needs to be prepared for use after construction
	due to post-clone recompilation, have a patcher registered to
	intercept the object that was recompiled.

Amendment of patching

	For the same reason as for constructors and destructors,
	inheritors being able to rewrite the inheritance tree of their
	objects at any time they see fit also makes guarantees for
	patching impossible.

	Therefore, going forward, we will simplify the regime, and the
	responsibilities of affected programs will be amended.

	Please see PATCHING for more information.

	When the new patching interface is built, any further
	recompilations of an object will cause it and its clones to be
	checked against the new patching api.

	It's also possible to use a patcher to intercept objects that
	newly inherit an inheritable after being originally created.

Deprecation of multiple archetypes

	(depends on amendment of cdtors)

	To avoid exponential complexity in a few areas, as well as
	encourage neater data inheritance, multiple archetypes are
	deprecated.

	They will be forbidden in the future, and later forcibly removed.

	To prepare for this change any object with multiple archetypes
	should be reworked.

	Step 1

		New API will be provided to query and set a single
		archetype.

			For the time being, the interface will manipulate
			the archetype array as if it had a single
			element.

			set_archetype will set this array to a single
			element array

			query_archetype will return nil if the array is
			empty or the only element if there is one, and
			will raise an error if the object has multiple
			archetypes.

		Formal deprecation.

			Warnings will be logged if an attempt is made to
			assign multiple archetypes to an object.

	Step 2

		The old api will raise runtime errors if an attempt is
		made to assign multiple archetypes to an object.

		The old api will also issue warnings if it is used at
		all.

	Step 3

		The new api will become mandatory.

		The old api will be completely removed.

		Any object with multiple archetypes will have their
		archetype list truncated to the first archetype.

Deprecation of system wide suspension

	It has been brought to my attention that the callout suspension
	API is bugged, namely that if a callout goes off during a
	suspension it could change its handle without this being properly
	reflected to the function handling the callout.  This, combined
	with the propensity for a connection suspension to go awry, has
	led me to conclude that system wide suspension is a no go.

	Please note that separate suspension of connections, by rejecting
	new connections and blocking existing ones, will remain supported
	via the System UserD.  It is required to prevent logins during
	boot and may also be useful in other cases.

	Step 1 (completed)

		Formal deprecation.

		Attempts to use the suspension API will result in warning
		messages.

	Step 2

		Forbid further usage of SuspendD.

		Allow previous usage to flush out and get processed.

		Any system that is suspended at this point will be forcibly released.

	Step 3

		Remove SuspendD from service.

Deprecation of callout suspension

	(depends on deprecation of system wide suspension)

	Due to the aforementioned bug, callout suspension is being
	removed.  Which is fine, it was always a royal pain in the ass.

	Step 1 (completed)

		Formal deprecation.

	Step 2

		Forbid further usage of CalloutD.

		Forcibly release callouts.

	Step 3

		Remove CalloutD from service.
