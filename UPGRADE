How to upgrade your mud
-----------------------

Every upgrade has the following sequence of events:

1.  advanced notice

	Any API changes will be announced at least one version in advance.

	For the purposes of this section, a change means anything that
	will cause the old API to be unusable.

	Unless otherwise noted, until the old API is obsoleted, it will
	remain valid to use both APIs at the same time, though warnings
	may be issued if the old API is used.

2.  preparation

	If anything needs done to prepare for an upgrade, those
	instructions will be provided, and should be completed before the
	actual upgrade.

3.  upgrade

	Use the upgrade command to start the upgrade process.

	This command is responsible for taking care of all of kotaka's
	native code.

4.  post upgrade work

	Instructions may be provided for things needing to be done after
	the upgrade is completed.

5.  recompiling (optional)

	It is advisable to keep all objects up to date with reference to
	their source code and inherits.

	Anything that depends on a source or header file that has been
	changed, or inherits a library that has been recompiled, should
	be recompiled as well.

Current API changes pending
---------------------------

Deprecation of constructors and destructors

	I just realized that inheritables can be added and removed from
	an object's inheritance tree at will by anyone with access to the
	object's source code.

	They are therefore completely useless.

	From now on, an object's top level destructor should cooperate
	and call the needed destructors itself up the inheritance tree.

	It is strongly advised that inheritables are fully prepared to be
	removed from an object's inheritance tree at any time at the will
	of its inheritors.

	Step 1 (completed)

		Formal deprecation.

		Initds who return answers to the queries will flag
		warning messages.

	Step 2

		Initds will no longer be queried about them and calls to them
		will no longer be made during creation or destruction.

	Step 3

		The PROGRAM_INFO lwo will be purged of all related fields
		and queries of such fields will trigger the standard
		runtime error for calling an undefined function.

Deprecation of patchers

	For the same reason as for constructors and destructors,
	inheritors being able to rewrite the inheritance tree of their
	objects at any time they see fit also makes guarantees for
	patching impossible.

	From now on, an inheritable must keep track of its own version
	information for its data.

	Step 1 (completed)

		Formal deprecation.  Any InitD that attempts to return
		information will provoke a warning.

	Step 2

		ObjectD will no longer ask for them.

		They will no longer be called.

	Step 3

		The PROGRAM_INFO lwo will be stripped of information.

Deprecation of multiple archetypes (depends on deprecation of
constructors and destructors)

	To avoid exponential complexity in a few areas, as well as encourage
	neater data inheritance, multiple archetypes are deprecated.

	They will be forbidden in the future, and later forcibly removed.

	To prepare for this change any object with multiple archetypes
	should be reworked.

	Step 1

		New API will be provided to query and set a single archetype.

			For the time being, the interface will manipulate
			the archetype array as if it had a single
			element.

			set_archetype will set this array to a single element array

			query_archetype will return nil if the array is
			empty or the only element if there is one, and
			will raise an error if the object has multiple archetypes.

		Formal deprecation.

			Warnings will be logged if an attempt is made to assign
			multiple archetypes to an object.

	Step 2

		The old api will raise runtime errors if an attempt is
		made to assign multiple archetypes to an object.

		The old api will also issue warnings if it is used at all.

	Step 3

		The new api will become mandatory.

		The old api will be completely removed.

		Any object with multiple archetypes will have their
		archetype list truncated to the first archetype.

ModuleD will be official registry for modules

	In the future, the existence of a module's InitD will no longer
	be the official indication of the module's being online.

	Step 1

		Usage of the module's initd's existence as an indication
		of the module's status will be formally deprecated.

		Going forward, ModuleD should be explicitly queried
		regarding a module's state.

		ModuleD's interface for booting and shutting down modules
		should be used exclusively.

		A module can be nuked even if it's shut down to enforce a
		complete purge of its owned objects.

	Step 2

		ModuleD's record on the status of a particular module
		will no longer automatically reflect the status of the
		module's initd.

		Modules will only be sent signals by ModuleD if they are
		officially online according to ModuleD's records

		A module registered as online, but whose initd is not
		compiled, will be an anomalous state that will generate a
		runtime error.  Such a detected status will cause the
		defunct module's missing initd to be deprived of signals.
