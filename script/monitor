#!/bin/bash

# signal handlers

function sigchld
{
	if (( CATCH == 1 ))
	then
		EXITED=1
	fi
}

function sighandler
{
	SIGNALLED=1
}

# signal procedures

function sigterm
{
	echo "+++ Monitor received SIGTERM, terminating DGD +++"
	trap - SIGTERM
	kill -TERM $DGDPID
	kill -TERM $$
}

function sigint
{
	echo "+++ Monitor received SIGINT, killing DGD +++"
	trap - SIGINT
	kill -KILL $DGDPID # DGD ignores SIGINT
	kill -INT $$
}

# subroutines

function execdgd
{
	trap "" HUP
	trap "" INT
	exec ~/bin/dgd $*
}

function boot
{
	rm -f state/swap
	if [ -f state/snapshot ]
	then
		echo "--- DGD warm booting ---"
		if [ -f state/snapshot.old ]
		then
			# both are present, possible incremental snapshot
			CATCH=1
			execdgd kotaka.dgd state/snapshot state/snapshot.old &
		else
			# only the full one
			CATCH=1
			execdgd kotaka.dgd state/snapshot &
		fi
	else
		if [ -f state/snapshot.old ]
		then
			# we only have the old one
			echo "--- DGD cool booting ---"
			CATCH=1
			execdgd kotaka.dgd state/snapshot.old &
		else
			# complete cold start
			echo "--- DGD cold booting ---"
			CATCH=1
			execdgd kotaka.dgd &
		fi
	fi
	DGDPID=$!
}

function exited
{
	case $EXITCODE in
	0)
		echo "--- DGD terminated normally ---"
		;;
	*)
		echo "--- DGD terminated abnormally (code $EXITCODE) ---"
		exit
		;;
	esac
}

function crashed
{
	if [ -f mud/core ]
	then
		rm -rf crash
		mkdir crash
		gdb dgd mud/core -batch -ex bt > crash/trace
		mv mud/core crash
		echo "+++ DGD terminated by SIG$SIGNAME (core dump processed) +++"
	else
		echo "+++ DGD terminated by SIG$SIGNAME +++"
	fi
}

function signalled
{
	SIGNAME=`kill -l $(( EXITCODE - 128 ))`

	case $SIGNAME in
	KILL|TERM|INT|HUP)
		echo "+++ DGD terminated by SIG$SIGNAME +++"
		exit
		;;
	*)
		crashed
		;;
	esac
}

function doeintr
{
	SIGNAME=`kill -l $(( EXITCODE - 128 ))`

	case $SIGNAME in
	TERM)
		sigterm
		;;
	INT)
		sigint
		;;
	HUP)
		echo "+++ Monitor received SIG$SIGNAME (ignoring) +++"
		;;
	*)
		echo "+++ Monitor received unexpected SIG$SIGNAME +++"
		;;
	esac
}

function doexit
{
	BOOTED=0
	if (( EXITCODE < 128 ))
	then
		exited
	else
		signalled
	fi
}

exec < /dev/null
exec >> kotaka.err
exec 2>&1

cd ~/git/kotaka

trap sighandler SIGTERM
trap sighandler SIGINT
trap sighandler SIGHUP
trap sigchld SIGCHLD

set -m

echo "--- Monitor starting ---"

BOOTED=0
SIGNALLED=0
EXITED=0

while true
do
	if (( BOOTED == 0 ))
	then
		BOOTED=1
		EXITED=0
		boot
	fi

	wait $DGDPID
	EXITCODE=$?
	CATCH=0

	if (( EXITED == 1 ))
	then
		BOOTED=0
		doexit
	else
		doeintr
	fi
done
